// SPDX-License-Identifier: GPL-3.0-only

// USB-PD driver for TPS65987 and the mostly compatible TPS65993 and TPS65994.
// I2C register reference: https://www.ti.com/lit/ug/slvubh2b/slvubh2b.pdf

#include <arch/time.h>
#include <board/battery.h>
#include <board/gpio.h>
#include <board/power.h>
#include <board/usbpd.h>
#include <common/debug.h>
#include <ec/i2c.h>

#define PORT_A_ADDRESS 0x20
#define PORT_B_ADDRESS 0x24

#define REG_MODE 0x03
#define REG_CMD1 0x08
#define REG_DATA1 0x09
#define REG_INT_EVENT_1 0x14
#define REG_INT_EVENT_2 0x15
#define REG_INT_CLEAR_1 0x18
#define REG_INT_CLEAR_2 0x19
#define REG_GLOBAL_CONFIG 0x27
#define REG_ACTIVE_CONTRACT_PDO 0x34

#ifndef HAVE_PD_IRQ
#define HAVE_PD_IRQ 0
#endif

enum {
    // PDO is empty
    USBPD_ERR_PDO_ZERO = 0x1000,
    // I2C error
    USBPD_ERR_I2C = 0x2000,
    // Incorrect register length
    USBPD_ERR_REG_LEN = 0x3000,
    // Unsupported PDO type was received
    USBPD_ERR_PDO_TYPE_UNSUP = 0x4000,
};

enum {
    // Fully functional, normal operation
    USBPD_MODE_APP = 0,
    // PD controller is running BIST
    USBPD_MODE_BIST,
    // PD controller booted in dead battery mode
    USBPD_MODE_BOOT,
    // Simulated port disconnect by previously issued DISC command
    USBPD_MODE_DISC,
    // Other values indicate limited functionality
    USBPD_MODE_UNKNOWN,
    // An error occured while reading mode
    USBPD_MODE_I2C_ERR,
};

#define PDO_KIND(pdo) ((uint8_t)((pdo) >> 30 & 3))

enum {
    PDO_KIND_FIXED = 0,
    PDO_KIND_BATTERY,
    PDO_KIND_VARIABLE,
    PDO_KIND_AUGUMENTED,
};

#define PDO_CURRENT_MA(pdo) (((pdo) & 0x3FF) * 10)

#define TPSA        0x20     // Port A I2C_EC address (BOOT address is A only)  (DS §8.3.10.3/Tab.8-5)
#define TPSB        0x24     // Port B (not valid in BOOT)

// Unique Address / Host-IF registers (same family layout)
#define REG_MODE        0x03
#define REG_CMD1        0x08
#define REG_DATA1       0x09
#define REG_GLOBAL_CFG  0x27

// ---- 4CC commands (fill from TI Host Interface TRM) -------------------------
#define CMD_GAID   FOURCC('G','A','I','D')  // exit modal tasks / reset to APP (family known)
#define CMD_DBFG   FOURCC('D','B','f','g')  // clear dead-battery; switch to VIN_3V3 (family known)
// The following three are TRM-specific; define with correct 4CCs for TPS65994:
#define CMD_PTCH_ENTER   FOURCC('P','T','C','H')  // enter patch/boot loader
#define CMD_I2C3M_XFER   FOURCC('I','2','C','m')  // issue an I2C3m transaction (write/read)
#define CMD_REBOOT       FOURCC('R','S','T','A')  // reboot/apply (or GAID is sufficient on some variants)
// -----------------------------------------------------------------------------

static inline int16_t tps_send4cc(uint8_t addr, uint32_t fourcc)
{
    uint8_t cmd[5] = { 4,
        (uint8_t)(fourcc      & 0xFF),
        (uint8_t)((fourcc>>8) & 0xFF),
        (uint8_t)((fourcc>>16)& 0xFF),
        (uint8_t)((fourcc>>24)& 0xFF)
    };
    return i2c_set(&I2C_USBPD, addr, REG_CMD1, cmd, sizeof(cmd));
}

static inline int tps_wait_ready(uint8_t addr, uint32_t timeout_ms)
{
    // Simple poll that the device is not in UNKNOWN and accepts a read to MODE
    uint8_t reg[5] = {0};
    uint32_t t0 = time_get();
    while (time_get() - t0 < timeout_ms) {
        int16_t r = i2c_get(&I2C_USBPD, addr, REG_MODE, reg, sizeof(reg));
        if (r >= 4) return 0;
    }
    return -1;
}

/* ------------------- Permanent EEPROM programming ------------------------ */
/* You must provide a TI Application-Configuration blob where the
 * Highest-Power sink policy is enabled. The blob typically targets an
 * external 0x50 EEPROM and is generated by TI’s Application Customization Tool.
 *
 * The writer below uses the TPS’s I2C3m via host 4CC (CMD_I2C3M_XFER) to
 * page-write the EEPROM and verify it.
 */

#define EE_ADDR         0x50        // 7-bit EEPROM address on I2C3m (DS §8.3.10/Tab.8-4)
#define EE_PAGE         64          // common 24xx256-style page size (adjust to your part)
#define EE_ADDR_BYTES   2           // 16-bit word address

// Helper to emit an I2C3m write:   [S][0xA0|W][AH][AL][data...][P]
// The payload and exact struct for CMD_I2C3M_XFER comes from the TRM.
// This function builds the on-the-wire bytes and wraps them in that struct.
static int tps_i2c3m_write(uint8_t dev7, uint16_t mem, const uint8_t *data, uint16_t len)
{
    // Build on-the-wire buffer: dev8, AH, AL, data...
    uint8_t w[EE_ADDR_BYTES + EE_PAGE + 1];
    uint8_t dev8w = (dev7 << 1) | 0; // write
    w[0] = dev8w;
    w[1] = (uint8_t)(mem >> 8);
    w[2] = (uint8_t)(mem & 0xFF);
    for (uint16_t i = 0; i < len; ++i) w[EE_ADDR_BYTES + 1 + i] = data[i];

    // Wrap into TRM-defined DATA1 payload for I2C3m write then kick CMD1.
    // Typical layout is: [len, ...bytes...] written to REG_DATA1 before CMD_I2C3M_XFER.
    uint8_t payload_len = (uint8_t)(EE_ADDR_BYTES + 1 + len);
    int16_t r = i2c_set(&I2C_USBPD, TPSA, REG_DATA1, w, payload_len);
    if (r < 0) return r;
    r = tps_send4cc(TPSA, CMD_I2C3M_XFER);
    if (r < 0) return r;
    // Give EEPROM its internal write time (tWR ~5ms typical); TPS may also stretch.
    mdelay(10);
    return 0;
}

static int tps_i2c3m_read(uint8_t dev7, uint16_t mem, uint8_t *out, uint16_t len)
{
    // Depending on TRM, a combined write-then-read transaction is supported.
    // Build probe with dev8W + addr, then dev8R and length; wrap and CMD_I2C3M_XFER.
    // For brevity, do two calls: write address, then read len bytes.
    // (Fill exact payload structure from TRM)
    (void)dev7; (void)mem; (void)out; (void)len;
    return -ENOSYS; // left to fill from TRM
}

int tps65994_program_eeprom(const uint8_t *blob, uint32_t blob_len)
{
    // 1) Put device in PTCH/BOOT context where I2C3m is available and PD is quiescent.
    if (tps_send4cc(TPSA, CMD_DBFG) < 0) return -1;
    if (tps_wait_ready(TPSA, 100) < 0) return -1;
    if (tps_send4cc(TPSA, CMD_PTCH_ENTER) < 0) return -1;
    if (tps_wait_ready(TPSA, 100) < 0) return -1;

    // 2) Page program the external EEPROM at 0x50 using I2C3m.
    uint32_t off = 0;
    while (off < blob_len) {
        uint16_t page_off = (uint16_t)(off % EE_PAGE);
        uint16_t wr = EE_PAGE - page_off;
        if (wr > blob_len - off) wr = (uint16_t)(blob_len - off);

        int r = tps_i2c3m_write(EE_ADDR, (uint16_t)off, &blob[off], wr);
        if (r < 0) { ERROR("EEPROM write failed @0x%lx\n", (unsigned long)off); return r; }
        off += wr;
    }

    // (Optional) 3) Verify a few sentinel bytes or full blob with tps_i2c3m_read().
    // Left as an exercise once TRM payload is filled.

    // 4) Reboot PDC to load from EEPROM.
    tps_send4cc(TPSA, CMD_REBOOT);   // or GAID on this family
    tps_wait_ready(TPSA, 200);

    return 0;
}

/* Example glue that burns just the “Highest-Power sink policy” config:
 * In practice, use a TI-generated Application Configuration blob that
 * already has the bit set. */
extern const uint8_t tps_appcfg_blob[];
extern const uint32_t tps_appcfg_blob_len;

void usbpd_fix_apply_permanent(void)
{
    if (tps65994_program_eeprom(tps_appcfg_blob, tps_appcfg_blob_len) == 0)
        INFO("TPS65994: EEPROM updated; multiport highest-power policy is permanent now.\n");
    else
        ERROR("TPS65994: EEPROM update failed.\n");
}




static int16_t usbpd_current_limit(uint8_t address) {
    uint8_t value[7] = { 0 };
    int16_t res = i2c_get(&I2C_USBPD, address, REG_ACTIVE_CONTRACT_PDO, value, sizeof(value));
    if (res == 7) {
        if (value[0] == 6) {
            uint32_t pdo = ((uint32_t)value[1]) | (((uint32_t)value[2]) << 8) |
                (((uint32_t)value[3]) << 16) | (((uint32_t)value[4]) << 24);
            if (!pdo)
                return -USBPD_ERR_PDO_ZERO;
            DEBUG("USBPD PDO %08lX ", pdo);
            if (PDO_KIND(pdo) == PDO_KIND_FIXED) {
                DEBUG("FIX ");
                DEBUG("%ld.%03ld A\n", PDO_CURRENT_MA(pdo) / 1000, PDO_CURRENT_MA(pdo) % 1000);
                return (int16_t)PDO_CURRENT_MA(pdo);
            } else if (PDO_KIND(pdo) == PDO_KIND_BATTERY) {
                DEBUG("BAT\n");
                //TODO
                return -USBPD_ERR_PDO_TYPE_UNSUP;
            } else if (PDO_KIND(pdo) == PDO_KIND_VARIABLE) {
                DEBUG("VAR ");
                DEBUG("%ld.%03ld A\n", PDO_CURRENT_MA(pdo) / 1000, PDO_CURRENT_MA(pdo) % 1000);
                return (int16_t)PDO_CURRENT_MA(pdo);
            } else {
                DEBUG("AUG\n");
                //TODO
                return -USBPD_ERR_PDO_TYPE_UNSUP;
            }
        } else {
            return -(USBPD_ERR_REG_LEN | (int16_t)value[0]);
        }
    } else if (res < 0) {
        return res;
    } else {
        return -(USBPD_ERR_I2C | res);
    }
}

static void usbpd_dump(uint8_t address) {
    /* Dump all registers for debugging */
    for (uint8_t reg = 0x00; reg < 0x40; reg += 1) {
        uint8_t value[65] = { 0 };
        int16_t res = i2c_get(&I2C_USBPD, address, reg, value, sizeof(value));
        if (res < 0) {
            DEBUG("USBPD %02X ERROR %04X\n", reg, res);
        } else {
            DEBUG("USBPD %02X OK %04X %02X =", reg, res, value[0]);
            for (int i = 0; i < (int)value[0]; i++) {
                DEBUG(" %02X", value[i + 1]);
            }
            DEBUG("\n");
        }
    }
}

#define FOURCC(a, b, c, d) (((((d) << 8) | (c)) << 8 | (b)) << 8 | (a))

// Check the operational state of the PD controller
static int16_t usbpd_get_mode(void) {
    int16_t res;
    int16_t mode;
    uint8_t reg[5] = { 0 };

    TRACE("USBPD controller mode: ");

    res = i2c_get(&I2C_USBPD, PORT_A_ADDRESS, REG_MODE, reg, sizeof(reg));
    if (res < 0 || reg[0] < 4) {
        TRACE("UNKNOWN (I2C error %d)\n", res);
        return USBPD_MODE_I2C_ERR;
    }

    mode = FOURCC(reg[1], reg[2], reg[3], reg[4]);

    switch (mode) {
    case FOURCC('A', 'P', 'P', ' '):
        TRACE("APP\n");
        return USBPD_MODE_APP;
    case FOURCC('B', 'I', 'S', 'T'):
        TRACE("BIST\n");
        return USBPD_MODE_BIST;
    case FOURCC('B', 'O', 'O', 'T'):
        TRACE("BOOT\n");
        return USBPD_MODE_BOOT;
    case FOURCC('D', 'I', 'S', 'C'):
        TRACE("DISC\n");
        return USBPD_MODE_DISC;
    }

    TRACE("UNKNOWN %llx\n", mode);
    return USBPD_MODE_UNKNOWN;
}

// Return to normal operation
// Cold resets the PD controller and exits any modal tasks
void usbpd_reset(void) {
    int16_t res;

    uint8_t cmd[5] = { 4, 'G', 'A', 'I', 'D' };

    res = i2c_set(&I2C_USBPD, PORT_A_ADDRESS, REG_CMD1, cmd, sizeof(cmd));
    if (res < 0)
        return;

    i2c_reset(&I2C_USBPD, true);
    return;
}

// Clear dead battery flag
// Switches the PD controller power supply from Vbus to VIN_3V3
static void usbpd_dbfg(void) {
    int16_t res;

    uint8_t cmd[5] = { 4, 'D', 'B', 'f', 'g' };

    res = i2c_set(&I2C_USBPD, PORT_A_ADDRESS, REG_CMD1, cmd, sizeof(cmd));
    if (res < 0)
        return;

    i2c_reset(&I2C_USBPD, true);
    return;
}

// Enables automatic sink management policy
// Port with highest negotiated power will be used
static void usbpd_set_multiport_policy(void) {
    int16_t res;
    uint8_t reg[15] = { 0 };

    DEBUG("USBPD set multiport policy\n");
    res = i2c_get(&I2C_USBPD, PORT_A_ADDRESS, REG_GLOBAL_CONFIG, reg, sizeof(reg));
    if (res < 0)
        return;

    DEBUG("USBPD multiport policy: %x\n", reg[4] & 0x01);
    if (reg[4] & 0x01)
        return;

    reg[4] |= 0x01; // Highest Power sink policy

    res = i2c_set(&I2C_USBPD, PORT_A_ADDRESS, REG_GLOBAL_CONFIG, reg, sizeof(reg));
    DEBUG("USBPD multiport policy set RES = %ld\n", res);
}

static void usbpd_clear_event() {
    int16_t res;
    uint8_t reg[12] = { 0 };

    DEBUG("USBPD IRQ\n");

    res = i2c_get(&I2C_USBPD, PORT_A_ADDRESS, REG_INT_EVENT_1, reg, sizeof(reg));
    if (res < 0)
        return;

    res = i2c_set(&I2C_USBPD, PORT_A_ADDRESS, REG_INT_CLEAR_1, reg, sizeof(reg));
    if (res < 0)
        return;

#ifdef USBPD_DUAL_PORT
    res = i2c_get(&I2C_USBPD, PORT_B_ADDRESS, REG_INT_EVENT_1, reg, sizeof(reg));
    if (res < 0)
        return;

    res = i2c_set(&I2C_USBPD, PORT_B_ADDRESS, REG_INT_CLEAR_1, reg, sizeof(reg));
    if (res < 0)
        return;
#endif
}

// Check the operational mode of the PDC and kick it if it has been in a bad
// mode for over 1 second.
static void usbpd_check_mode() {
    static uint32_t time_start = 0;

    if (power_state != POWER_STATE_G3 && usbpd_get_mode() == USBPD_MODE_UNKNOWN && !time_start)
        time_start = time_get();
    else
        time_start = 0;

    // Kick the PDC if it's been in a bad state for over 1 second
    if (time_start && (time_get() - time_start) > 1000) {
        WARN("PDC timeout!\n");
        usbpd_reset();
        while (usbpd_get_mode() == USBPD_MODE_UNKNOWN && (time_get() - time_start) <= 2000)
            ;

        if ((time_get() - time_start) > 2000)
            ERROR("Timed out waiting for PDC to reset!\n");

        time_start = 0;
    }
}

void usbpd_event(void) {
    bool update = false;
    int16_t res;

    static bool last_ac_in = false;
    bool ac_in = !gpio_get(&ACIN_N);
    if (ac_in != last_ac_in) {
        last_ac_in = ac_in;
        update = true;

        DEBUG("AC_IN %d\n", ac_in);
    }

    static bool last_jack_in = false;
    bool jack_in = !gpio_get(&JACK_IN_N);
    if (jack_in != last_jack_in) {
        last_jack_in = jack_in;
        update = true;

        DEBUG("JACK_IN %d\n", jack_in);
    }

    static bool last_sink_ctrl_1 = false;
    bool sink_ctrl_1 = gpio_get(&SINK_CTRL);
    if (sink_ctrl_1 != last_sink_ctrl_1) {
        last_sink_ctrl_1 = sink_ctrl_1;
        update = true;

        DEBUG("SINK_CTRL %d\n", sink_ctrl_1);
    }

#ifdef USBPD_DUAL_PORT
    static bool last_sink_ctrl_2 = false;
    bool sink_ctrl_2 = gpio_get(&SINK_CTRL_2);
    if (sink_ctrl_2 != last_sink_ctrl_2) {
        last_sink_ctrl_2 = sink_ctrl_2;
        update = true;

        DEBUG("SINK_CTRL_2 %d\n", sink_ctrl_2);
    }
#endif

    usbpd_check_mode();

    static enum PowerState last_power_state = POWER_STATE_G3;
    update_power_state();
    if (power_state != last_power_state) {
        update = true;

        if (last_power_state == POWER_STATE_G3) {
            // VIN_3V3 now available, allow PD to use it instead of Vbus
            usbpd_dbfg();
#ifdef USBPD_DUAL_PORT
            // This resets the PD port so it has to be done after dbfg
            // TODO: Calling this causes PD reset which in turn causes a race
            // condition in PMC, preventing boot.
            // Instead of runtime patching, perform a full EEPROM update in
            // coreboot.
            //usbpd_set_multiport_policy();
#endif
        }
        last_power_state = power_state;
    }

    if (update) {
        // Default to disabling input current
        uint16_t next_input_current = 0;
        uint16_t next_input_voltage = 0;
        uint16_t retry = 1000;

        if (ac_in) {
            if (jack_in) {
                // Use default input current
                next_input_current = CHARGER_INPUT_CURRENT;
                next_input_voltage = BATTERY_CHARGER_VOLTAGE_AC;
            } else if (sink_ctrl_1) {
                while ((res = usbpd_current_limit(PORT_A_ADDRESS)) < 0 && retry--) {};
                next_input_current = res < CHARGER_INPUT_CURRENT ? res : CHARGER_INPUT_CURRENT;
                next_input_current = (uint32_t)next_input_current * 93 / 100;
                next_input_voltage = BATTERY_CHARGER_VOLTAGE_PD;
#ifdef USBPD_DUAL_PORT
            } else if (sink_ctrl_2) {
                while ((res = usbpd_current_limit(PORT_B_ADDRESS)) < 0 && retry--) {};
                next_input_current = res < CHARGER_INPUT_CURRENT ? res : CHARGER_INPUT_CURRENT;
                next_input_current = (uint32_t)next_input_current * 93 / 100;
                next_input_voltage = BATTERY_CHARGER_VOLTAGE_PD;
#endif
            }
        }

        if (next_input_current != battery_charger_input_current_ma) {
            battery_charger_input_current_ma = next_input_current;
            battery_charger_input_voltage_v = next_input_voltage;
            DEBUG("CHARGER LIMIT %d mA\n", battery_charger_input_current_ma);

            // Disable smart charger so it is reconfigured with the new limit
            battery_charger_disable();
            // In case power was renegotiated without power loss
            power_apply_limit(true);
        }
    }

#if HAVE_PD_IRQ
    /* For now, all we do is clear all events */
    if (power_state != POWER_STATE_G3 && !gpio_get(&PD_IRQ))
        usbpd_clear_event();
#endif
}

void usbpd_init(void) {
    i2c_reset(&I2C_USBPD, true);
}
